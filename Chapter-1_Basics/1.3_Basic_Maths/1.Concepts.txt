Basics of Maths

==========================================================================================

1. Digits

-> Taking a simple example "7789" extract the digits out of it i.e. "7,7,8,9" 
-> How can we achieve this ?

Sol: To achieve these digits we need to do "% 10" 

        7789 % 10 => will generate "9" for first time 
        7789 % 10 = 7789 / 10 return remainder => 7789 - 7780 = 9

        now to get the next digit "8" I need to do "/10" and integer round off that:

        7789 / 10 => 778.9 => round(778.9) => 778 => 778 % 10 => 8 
        
        So likewise we proceed with this and get the digits.

==========================================================================================        

2. Reverse a Number

-> Takes "7789" => "9877"
-> How?

Sol:
        1. Do the same thing as we did in extraction.

        2. Assign one variable "reverse_number".

        3. In the "reverse_number = (reverse_number x 10) + last_digit"

        example => 7789 => 7789 % 10 => 9
                          reverse_number = 0

                          reverse_number = reverse_number x 10 + last_digit
                                                    = (0 x 10) + 9
                                                    = 9

        In the same fashion we will generate all and we get the "reverse_number = 9877"                                            

==========================================================================================

3. Palindrome

-> Takes "121" => "reverse = 121" if both equal YES else NO
-> How?

Sol:
        1. Do the same thing as we did in extraction.

        2. Apply Reverse Procedure.

        3. Check if Reverse == Original ? then Palindrome else NOT

        example : 121 => rev(121) = 121 => 121 == 121 ? YES then Palindrome

==========================================================================================

4. Armstrong

-> Takes "371" => len(371) = 3 => so 3^3 + 7^3 + 1^3 = 371 then Armstrong else NOT
-> How?

Sol:
        1. Do the same thing as we did in extraction.

        2. Do the summation of (extracted_digits) ^ len(given Number)

        3. Check if summation == Original ? then Armstrong else NOT

==========================================================================================

5. Give all Divisors

-> Takes "8" => divisors [ 1 to N= 8] => 1,2,4,8
-> How?

Sol:
        1. Loop over from "1 to given Number"

        2. Check if Number % i == 0  then divisor else NOT

        example: Number = 8 => loop from (1 to 8)
                                          => 8 % 1 == 0 yes , 8 % 2 == 0 yes , 8 % 3 == 0 No....etc till 8 % 8 == 0 yes
                                          => print those numbers which gave "YES"      

Sol: Another faster approach

        1. Take root of given Number N = 36 -> 6 

        2. Go from 1 to sqrt(Number) i.e. 1 to 6 now

        3. add "i" during looping and "N//i" in your set() to get unique numbers only 

        example : N = 4 => sqrt(4) = 2 
                                 -> loop (1 to 2)
                                 -> i = 1 add to set , 4//1 add to set ,
                                 -> i = 2 add to set . 4//2 add to set
                                 set = {1,2,4}

==========================================================================================

6. Prime Numbers

-> Takes "3" => Check factors ? if factors = 2 i.e. 1 & N itself then Prime
-> How?

Sol:
        1. Do the same thing as we did in extraction.

        2. Do the summation of (extracted_digits) ^ len(given Number)

        3. Check if summation == Original ? then Armstrong else NOT

==========================================================================================

7. Finding GCD / HCF

-> Takes tow nos. let say 20 , 40 find the hcf(20,40) => 20 
    as it is the highest common factor dividing them
-> How?

Sol:
        1. Loop from 1 to min(n1,n2).

        2. Check if n1 % i == 0 and n2 % i == 0 => gcd = i

Another approach is using "Euclidean Algorithm"

"gcd(a,b) = gcd(a-b , b)"  where  "a > b"

this will continue until one of the number becomes "0"
then the left out number will be the "GCD".

But this approach can be inefficient if the numbers are large.
So what to do is ;

        gcd(a,b) == gcd(a % b , b) ; 
        where a > b